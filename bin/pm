#!/bin/bash

# powscript general settings
set -e                         # halt on error
set +m                         #
SHELL="$(echo $0)"             # shellname
SHELLNAME="$(basename $SHELL)" # shellname without path
shopt -s lastpipe              # flexible while loops (maintain scope)
shopt -s extglob               # regular expressions
path="$(pwd)"
selfpath="$( dirname "$(readlink -f "$0")" )"
tmpfile="/tmp/$(basename $0).tmp.$(whoami)"
which flock &>/dev/null        || { echo "dependency error: it seems 'flock' is not installed (please install it)"; }
which awk &>/dev/null          || { echo "dependency error: it seems 'awk' is not installed (please install it)"; }
which date &>/dev/null         || { echo "dependency error: it seems 'date' is not installed (please install it)"; }
which sleep &>/dev/null        || { echo "dependency error: it seems 'sleep' is not installed (please install it)"; }
which ps &>/dev/null           || { echo "dependency error: it seems 'ps' is not installed (please install it)"; }
which head &>/dev/null         || { echo "dependency error: it seems 'head' is not installed (please install it)"; }

scope=app
cmd=help

for arg in "$@"; do
  case $arg in
    exec)
      scope=process
      cmd=$arg
      shift
      ;;
    start)
      scope=process
      cmd=$arg
      shift
      ;;
    stop)
      scope=process
      cmd=$arg
      shift
      ;;
    restart)
      scope=process
      cmd=$arg
      shift
      ;;
    status)
      scope=process
      cmd=$arg
      shift
      ;;
    init)
      scope=apps
      cmd=$arg
      shift
      ;;
    add)
      scope=apps
      cmd=$arg
      shift
      ;;
    remove)
      scope=apps
      cmd=$arg
      shift
      ;;
    --force)
      runtime=sh
      shift
      ;;
  esac
done

process:log(){
  date +"%Y-%m-%d %H:%M:%S $*"
  { which logger &>/dev/null && date +"%Y-%m-%d %H:%M:%S $*" | logger -i --tag pm; } &>/dev/null
}

process:gettmpfile(){
  local pname="${1}"
  echo /tmp/.pm.$(basename "$pname")
}

process:getpidfile(){
  local pname="${1}"
  echo $(process:gettmpfile "$pname").pid
}

process:getpid(){
  local pname="${1}"
  local pidfile=$(process:getpidfile "$pname")
  if [[ -f "$pidfile" ]]; then
    cat "$pidfile"
  else 
    echo -1
  fi
}

process:getlockfile(){
  local pname="${1}"
  local tmpfile=$(process:gettmpfile "$pname")
  echo "$tmpfile".lock
}

process:getlogfile(){
  local pname="${1}"
  local tmpfile=$(process:gettmpfile "$pname")
  echo "$tmpfile".log
}

process:exec(){
  local pname="${1}"
  shift # remove first arg from argument array
  cnt=1
  lockfile=$(process:getlockfile "$pname")
  trap "process:log \"#$cnt: "$pname" killed \$?\"; pkill -P $$" EXIT SIGHUP SIGINT SIGTERM
  while :; do
    process:log "#$cnt "$pname" started [pid $$]"
    flock -w 0 "$lockfile" "$pname" "$@" || exit 1
    code="$?"                                 # check exit status code
    exit="EXIT"
    if [[ "$code" == 129 ]]; then
      exit=SIGHUP
    fi
    if [[ "$code" == 130 ]]; then
      exit=SIGINT
    fi
    if [[ "$code" == 143 ]]; then
      exit=SIGTERM
    fi
    process:log "#$cnt "$pname" "$exit" [$code]"
    sleep 5s                                  # wait for seconds until next boot
    cnt=$(($cnt+1))                           # increment counter
  done
}

process:start(){
  local pname="${1}"
  shift # remove first arg from argument array
  pidfile=$(process:gettmpfile "$pname").pid
  logfile=$(process:getlogfile "$pname")
  lockfile=$(process:getlockfile "$pname")
  flock -w 0 "$lockfile" sleep 0.1s || { echo "already started"; exit 1; }
  nohup "$selfpath"/pm exec "$pname" "$@" 1>$logfile.stdout 2>$logfile.stderr &
  echo $! > "$pidfile" 
  echo -e "press CTRL-C to stop logmonitor:\n"
  set -x
  tailf "$logfile".stdout "$logfile".stderr
}

process:stop(){
  local pname="${1}"
  shift # remove first arg
  pid=$(process:getpid "$pname")
  if [[ ! "$pid" == "-1" ]]; then
    echo killing pid "$pid" 
    rm $(process:getpidfile "$pname")
    pkill -P "$pid"
  else
    echo "$pname is not running"
  fi
}

process:restart(){
  local pname="${1}"
  process:stop "$pname" &
  wait 
  process:start "$pname"
}

process:status(){
  local pname="${1}"
  ps=$(ps au)
  seen=()
  cols="$(echo "$ps" | head -n1)"                        # print cols header
  printf "%-10s %-10s %s\n" "APP" "STATUS" "$cols"
  echo "$ps" | grep "flock.*pm\..*\.lock" >> "$tmpfile".ps # print psdata
  for lockfile in "${ls[@]}" /tmp/.pm.*.lock; do
    appname=${lockfile/*pm\./}
    appname=${appname/\.lock/}
    echo "$appname"
    flock -w 0 "$lockfile" sleep 0.1s && status=running || status=stopped
    if [[ "$status" == "running" ]]; then
      printf "%-10s %-10s" "$appname" "$status"
    else
      line="$(fgrep "$lockfile" "$tmpfile".ps)"
      printf "%-10s %-10s %s\n" "$appname" "$status" "$line"
    fi
  done
}
     

config_file=~/.pm.conf.sh
tpl_config='
declare -A apps
apps=()
'

apps:init(){
  if [[ -f "$config_file" ]]; then
    echo "error: "$config_file" already exist..are you sure? (if so, please delete it)"
    exit 1
  else
    echo "$tpl_config" > "$config_file"
  fi
}
 
apps:add(){
  local appdir="${1}"
  echo add appdir=$appdir
}

apps:remove(){
  local appdir="${1}"
  echo remove appdir=$appdir
   
 }


pid=$$


app:init(){
  for dep in "${dependencies[@]}"; do
    which "$dep" &>/dev/null || { echo "'$dep' is not installed (pm needs: "$dependencies")" && exit 1; }
  done
}

app:help(){
  echo 'Usage:                                                                                                          '     
  echo '                                                                                                                '
  echo '  pm init                                      create ~/.pm.conf.sh configfile                                  '
  echo '  pm status                                    show app(names) and their status                                 '
  echo '  pm add <appdir>                              add application(dir which contains application definition file)  '
  echo '  pm remove <appdir>                           remove application                                               '
  echo '  pm start <appname> [args] [..]               start app                                                        '
  echo '  pm stop <appname>                            stop  app                                                        '
  echo '                                                                                                                '
  echo '                                               ┌─────────────────────────────────────────────────┐              '
  echo '                                               │ docs: https://github.com/coderofsalvation/pm.sh │              '
  echo '                                                                                                                '
}

app:init && "$scope":$cmd "$@"

# wait for all async child processes (because "await ... then" is used in powscript)
[[ $ASYNC == 1 ]] && wait


# cleanup tmp files
if ls /tmp/$(basename $0).tmp.sqz* &>/dev/null; then
  for f in /tmp/$(basename $0).tmp.sqz*; do rm $f; done
fi

exit 0


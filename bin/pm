#!/bin/bash

# Generated by POWSCRIPT (https://github.com/coderofsalvation/powscript)
#
# Unless you like pain: edit the .pow sourcefiles instead of this file

# powscript general settings
set -e                         # halt on error
set +m                         #
SHELL="$(echo $0)"             # shellname
SHELLNAME="$(basename $SHELL)" # shellname without path
shopt -s lastpipe              # flexible while loops (maintain scope)
shopt -s extglob               # regular expressions
path="$(pwd)"
selfpath="$( dirname "$(readlink -f "$0")" )"
tmpfile="/tmp/$(basename $0).tmp.$(whoami)"
#
# generated by powscript (https://github.com/coderofsalvation/powscript)
#

empty () 
{ 
    [[ "${#1}" == 0 ]] && return 0 || return 1
}

mappipe () 
{ 
    func="$1";
    shift;
    ( while read -r line; do
        $func "$@" "$line";
    done )
}

on () 
{ 
    func="$1";
    shift;
    for sig in "$@";
    do
        trap "$func $sig" "$sig";
    done
}

which flock &>/dev/null        || { echo "dependency error: it seems 'flock' is not installed (please install it)"; }
which awk &>/dev/null          || { echo "dependency error: it seems 'awk' is not installed (please install it)"; }
which date &>/dev/null         || { echo "dependency error: it seems 'date' is not installed (please install it)"; }
which sleep &>/dev/null        || { echo "dependency error: it seems 'sleep' is not installed (please install it)"; }
which ps &>/dev/null           || { echo "dependency error: it seems 'ps' is not installed (please install it)"; }
which head &>/dev/null         || { echo "dependency error: it seems 'head' is not installed (please install it)"; }

scope=app
cmd=help

opts:scanopts(){
  for arg in $@; do
    case $arg in
      --log)
        LOG=1
        shift
        ;;
      -h)
        ALL=1
        shift
        ;;
    esac
  done
}

opts:scancmd(){
  for arg in $@; do
    case $arg in
      server)
        scope=server
        cmd=start
        return 0
        ;;
      exec|debug|start|stop|restart|startall|stopall|list|inspect|status|tail)
        scope=process
        cmd=$arg
        break
        ;;
      init|add|remove)
        scope=apps
        cmd=$arg
        break
        ;;
      config)
        scope=config
        cmd=edit
        break
        ;;
    esac
  done
}


string:urlencode(){
  local string="${1}"
  local strlen=${#string}
  local encoded=""
  for (( pos=0 ; pos<strlen ; pos++ )); do
    o=""
    c=${string:$pos:1}
    if [[ $c =~ ([-_.~a-zA-Z0-9]) ]]; then
      o="${c}"
    else
      printf -v o '%%%02x' "'$c"
    fi
    encoded="$encoded""$o"
  done
  echo "${encoded}"
}


string:wraplines(){
  cut -c1-$(stty size <&2 | cut -d' ' -f2)
}

event:trigger_analytics(){
  local file="${1}"
  local appname="${2}"
  local type="${3}"
  local msg="${4}"
  logfile=$(process:getlogfile $appname).stdout
  if [[ ! -f $file ]]; then
    return 0
  fi
  source $file &>/dev/null
  if [[ -n $GOOGLE_ANALYTICS_TOKEN ]]; then
    if [[ ! -n $CLIENT_NAME ]]; then
      CLIENT_NAME=$(cat /etc/hostname)
    fi
    if [[ ! -n $APP_NAME ]]; then
      APP_NAME=$appname
    fi
    if [[ ! -n $CLIENT_ID ]]; then
      CLIENT_ID="$APP_NAME"
    fi
    if [[ ! -n $DATASOURCE ]]; then
      DATASOURCE="$APP_NAME"
    fi
    if [[ ! -n UID ]]; then
      UID="$APP_NAME"                          # update this if needed for better stats
    fi
    repo="$(process:getrepo $appname)"
    if ! empty $repo; then
      msg="$repo $msg"
      msg="${msg/^ /}"
    fi
    msg="$(string:urlencode "$msg")"
    process:log "pm.sh: posting to analytics" >> $logfile
    result="$(curl -vv -L -s --connect-timeout 2 -d "v=1&tid=$GOOGLE_ANALYTICS_TOKEN&uid=$UID&ds=$DATASOURCE&cid=$CLIENT_ID&t=event&ec=$SERVER_NAME&ea=$type&el=$msg" https://www.google-analytics.com/collect 2>&1 | fgrep '< HTTP/' )"
    process:log "pm.sh: $result" >> $logfile
  fi
}

event:trigger_webhook(){
  local appname="${1}"
  local type="${2}"
  local url="${3}"
  logfile=$(process:getlogfile $appname).stdout
  if empty $url; then
    return 1
  fi
  repo="$(process:getrepo $appname)"
  CLIENT_NAME=$(cat /etc/hostname)
  if [[ ${#repo} -gt 0 ]]; then
    msg="$msg $repo"
    msg="${msg/^ /}"
  fi
  process:log "pm.sh: posting to webhook $url" >> $logfile
  curl -vv -L -s --connect-timeout 2 -H 'Content-Type: application/json' -X POST $url --data '{"source":"pm.sh","server":"'$CLIENT_NAME'","app":"'$appname'","type":"'$type'","message":"'$msg'"}' "$url" 2>&1 | fgrep '< HTTP/' &> $tmpfile.curl
  while IFS="" read -r line; do
    process:log "pm.sh: $line" >> $logfile
  done < $tmpfile.curl
  return 0
}

event:trigger_webhooks(){
  local file="${1}"
  local appname="${2}"
  local type="${3}"
  if [[ ! -f $file ]]; then
    return 0
  fi
  cat $file | grep -vE '^#' | mappipe event:trigger_webhook $appname $type
}

event:trigger(){
  local appname="${1}"
  local type="${2}"
  local msg="${3}"
  apps:exit_if_nonexists $appname
  deffile="$(process:gettmpfile $appname).def"
  gafile=$(process:gettmpfile $appname).ga
  webhookfile=$(process:gettmpfile $appname).webhook
  event:trigger_analytics $gafile "$@"
  event:trigger_webhooks $webhookfile "$@"
}

process:log(){
  { which logger &>/dev/null && date +"%Y-%m-%d %H:%M:%S $*" | logger -t pm; } &>/dev/null
  date +"%Y-%m-%d %H:%M:%S $*"
}

process:gettmpfile(){
  local appname="${1}"
  if empty appname; then
    return 0
  fi
  echo $app_config_dir/apps/$(basename $appname)
}

process:getpidfile(){
  local appname="${1}"
  echo $(process:gettmpfile $appname).pid
}

process:getpid(){
  local appname="${1}"
  local pidfile=$(process:getpidfile $appname)
  if [[ -f $pidfile ]]; then
    cat $pidfile
  else
    echo -1
  fi
}

process:getlockfile(){
  local appname="${1}"
  local tmpfile=$(process:gettmpfile $appname)
  echo $tmpfile.lock
}

process:getlogfile(){
  local appname="${1}"
  local tmpfile=$(process:gettmpfile $appname)
  echo $tmpfile.log
}

process:exec(){
  local appname="${1}"
  shift
  cnt=0
  lockfile=$(process:getlockfile $appname)
  deffile=$(process:gettmpfile $appname).def
  cntfile=$(process:gettmpfile $appname).cnt
  workdir=$(apps:getworkdir $deffile)
  startcmd=$(apps:getstartcmd $deffile)
  cd $workdir
  trap "process:log \"#$cnt: $appname killed \$?\"; pkill -P $$" EXIT SIGHUP SIGINT SIGTERM
  process:setenv $workdir
  echo $cnt > $cntfile
  while :; do
    process:log "#$cnt $appname started [pid $$]: ${startcmd}"
    { flock -n $lockfile ${startcmd} || exit 1;}
    code="$?"                                 # check exit status code
    exit="EXIT"
    if [[ $code == 129 ]]; then
      exit=SIGHUP
    fi
    if [[ $code == 130 ]]; then
      exit=SIGINT
    fi
    if [[ $code == 143 ]]; then
      exit=SIGTERM
    fi
    process:log "#$cnt $appname $exit [$code]"
    event:trigger $appname exit "#$cnt exitcode $code"
    event:trigger $appname restart $cnt
    sleep 3s                                  # wait for seconds until next boot
    cnt=$(($cnt+1))                           # increment counter
    echo $cnt > $cntfile
    # handle odd/buggy case
    if [[ $cnt -gt 50 ]]; then
      event:trigger $appname error "restarted > 50 times"
      $selfpath/pm stop $appname
    fi
  done
}

process:setenv(){
  local workdir="${1}"
  if [[ -f $workdir/env.sh ]]; then
    source $workdir/env.sh
  fi
  if [[ -f $workdir/env.production.sh ]]; then
    source $workdir/env.production.sh
  fi
}

process:inspect(){
  local appname="${1}"
  apps:exit_if_nonexists $appname
  deffile=$(process:gettmpfile $appname).def
  pidfile=$(process:gettmpfile $appname).pid
  logfile=$(process:getlogfile $appname)
  lockfile=$(process:getlockfile $appname)
  startcmd=$(apps:getstartcmd $deffile)
  workdir=$(apps:getworkdir $deffile)
  pidvalue="n/a"
  if [[ -f $pidfile ]]; then
    pidvalue=$(<$pidfile)
  fi
  echo "appname                : "$appname
  echo "startcommand           : "$startcmd
  echo "workdir                : "$workdir
  echo "application definition : "$deffile
  echo "pidfile                : "$pidfile
  echo "logfile stdout         : "$logfile.stdout
  echo "logfile stderr         : "$logfile.stderr
  echo "lockfile               : "$lockfile
  echo "pidvalue               : "$pidvalue
  echo "repository             : "$(process:getrepo $appname)
  process:setenv $workdir
  set > $tmpfile.1
  set > $tmpfile.2
  diff -Nau $tmpfile.1 $tmpfile.2 | grep -E '^\+[A-Za-z][A-Za-z_0-9]+=' | sed 's/^+/environment            : /g'
  if [[ ! -f pidfile ]]; then
    echo -e "\nps. some files weren't created yet. Use 'pm start <appname>' first."
  fi
}

process:startall(){
  apps:every process:start
}

process:stopall(){
  apps:every process:stop
}

process:start(){
  local appname="${1}"
  apps:exit_if_nonexists $appname
  deffile=$(process:gettmpfile $appname).def
  pidfile=$(process:gettmpfile $appname).pid
  logfile=$(process:getlogfile $appname)
  lockfile=$(process:getlockfile $appname)
  flock -n $lockfile sleep 0.1s || { echo "already started"; exit 1; }
  nohup $selfpath/pm exec $appname 1>$logfile.stdout 2>$logfile.stderr &
  echo $! > $pidfile
  echo "$appname started"
  event:trigger $appname start
  if [[ -n $LOG ]]; then
    process:tail $appname
  fi
}

process:tail(){
  local appname="${1}"
  apps:exit_if_nonexists $appname
  deffile=$(process:gettmpfile $appname).def
  logfile=$(process:getlogfile $appname)
  echo -e "press CTRL-C to stop logmonitor:\n"
  tail -q -f $logfile.*
}

process:killtree(){
  local pid="${1}"
  pids="$pid";
  while pgrep -P $pid &>/dev/null; do
    pid=$(pgrep -P $pid)
    pids="$pids $pid"
  done
  echo "killing pids: $pids"
  kill -9 ${pids}
}

process:stop(){
  local appname="${1}"
  shift # remove first arg
  pid=$(process:getpid $appname)
  cntfile=$(process:gettmpfile $appname).cnt
  lockfile=$(process:getlockfile $appname)
  if [[ ! $pid == "-1" ]]; then
    rm $(process:getpidfile $appname)
    process:killtree $pid
    sleep 2s
    rm $lockfile
    touch $lockfile
  else
    echo "$appname is not running"
  fi
  echo 0 > $cntfile
  if [[ $appname == "pmserver" ]]; then
    server:kill
  fi
  event:trigger $appname stop
}

process:restart(){
  local appname="${1}"
  cntfile=$(process:gettmpfile $appname).cnt
  event:trigger $appname restart
  set +e ; process:stop $appname ; set -e
  process:start $appname
}

process:getport(){
  local appname="${1}"
  deffile=$(process:gettmpfile $appname).def
  workdir=$(apps:getworkdir $deffile)
  portfile=$(process:gettmpfile $appname).port
  port="none"
  if cd $workdir &>/dev/null; then
    if [[ -f env.sh ]]; then
      source env.sh &>/dev/null
      if [[ -n $PORT ]]; then
        port=$PORT
      fi
    fi
  fi
  if [[ -f $portfile ]]; then
    port=$(<$portfile)
  fi
  echo "$port"
}

process:ps(){
  local appname="${1}"
  local apppath="${2}"
  lockfile=$(process:getlockfile $appname)
  cntfile=$(process:gettmpfile $appname).cnt
  ps="$(ps au)"
  set +e
  psapp="$(echo "$ps" | fgrep $appname | fgrep flock | head -n1)"
  restarts=0
  if [[ -f $cntfile ]]; then
    restarts=$(cat $cntfile)
  fi
  status="stopped"
  port=$(process:getport $appname)
  if ! empty $psapp; then
    status="running"
  fi
  printf "%-20s %-8s %-6s %-10s %s\n" "$appname" "$status" $port $restarts "$psapp" | string:wraplines
}

process:status(){
  cols="$(ps au | head -n1)"                        # print cols header
  printf "%-20s %-8s %-6s %-10s %s\n\n" "APP" "STATUS" "PORT" "RESTARTS" "$cols" | string:wraplines
  apps:every process:ps
}

process:list(){
  local appname="${1}"
  apps:every echo | awk '{ print $1 }'
}

process:getrepo(){
  local appname="${1}"
  deffile=$(process:gettmpfile $appname).def
  workdir=$(apps:getworkdir $deffile)
  cd $workdir
  if [[ -f .git/config ]]; then
    repo="$( cat .git/config | grep url | head -n1 | sed 's/.*\///g' )"
    branch="$( git branch 2>&1 | grep "^*" | sed 's/ //g;s/^*//g'   )"
    hash="$(git rev-parse HEAD 2>/dev/null)"
    echo "$repo(${branch}:${hash:0:4})"
  fi
}

process:debug(){
  local appname="${1}"
  process:inspect $appname
  process:exec $appname
}


app_config_dir=~/.pm.sh

if ! empty $PM_CONFIG; then
  app_config_dir="$PM_CONFIG"
fi

apps:init(){
  local silent="${1}"
  if [[ ! -d $app_config_dir ]]; then
    mkdir -p $app_config_dir/apps
    echo "$selfpath/pm webserver" > $app_config_dir/apps/pmserver.def
    echo $app_config_dir > $app_config_dir/apps/pmserver.cwd
  fi
}

apps:exit_if_nonexists(){
  local appname="${1}"
  if [[ ! -n $1 ]]; then
    app:help
    exit 0
  fi
  deffile="$(process:gettmpfile $appname).def"
  if [[ ! -f $deffile ]]; then
    echo "app '$appname' does not exist, please use 'pm status' to list appnames"
    exit 1
  fi
}

apps:scan_application_definitions(){
  local appdir="${1}"
  if [[ -f $appdir/package.json ]]; then
    echo $appdir/package.json
  fi
  #if -f $appdir/composer.json
  #  echo $appdir/package.json
  #if -f $appdir/app.sh
  #  echo $appdir/package.json
  #if -f $appdir/app.json
  #  echo $appdir/package.json
}

apps:getworkdir(){
  local appdef="${1}"
  echo "$(< "${appdef/.def/.cwd}")"
}

apps:getstartcmd(){
  local appdef="${1}"
  appdeffile="$(<$appdef)"
  if [[ $appdeffile =~ (.*package.json$) ]]; then
    echo "npm start"
    return 0
  fi
  echo $appdeffile # app.sh or anything shell
}

apps:every(){
  local cb="${1}"
  for app in $app_config_dir/apps/*.def; do
    apppath="${app//\.def/}"
    appname="$(basename $apppath)"
    $cb $appname $apppath
  done
}

apps:add(){
  local appdir="${1}"
  local appname="${2}"
  if ! empty $appdir; then
    shift
  fi
  if ! empty $appname; then
    shift
  fi
  cmd="$*"
  app:init
  if [[ ! -d $appdir ]]; then
    echo "'$appdir' does not exist" && exit 1
  fi
  if [[ ! ${appdir:0:1} == "/" ]]; then
    appdir="$(pwd)/$appdir"
  fi
  defs=$( apps:scan_application_definitions $appdir )
  if empty $defs && empty $cmd; then
    echo -e "couldn't find application definition in $appdir, like:\n"
    echo "  * $appdir/package.json"
    echo "  * $appdir/composer.json"
    echo "  * $appdir/app.sh"
    echo "  * $appdir/app.json"
    echo ""
    echo " please provide one, or provide cmd as extra argument to 'pm add'"
    exit 1
  fi
  if empty $appname; then
    appname=$( basename $appdir )
  fi
  echo "$appdir" > "$app_config_dir/apps/$appname.cwd"
  if ! empty $cmd; then
    defs="$cmd"
  fi
  echo "$defs" | head -n1 > "$app_config_dir/apps/$appname.def"
  echo "'$appname' was added"
}

apps:remove(){
  local app="${1}"
  app:init
  if [[ ! -f $app_config_dir/apps/$app.def ]]; then
    echo -e "couldn't find application '$app'\n\nplease run 'pm status' to see all apps"
    exit 1
  fi
  $selfpath/pm stop $app &>/dev/null
  rm $app_config_dir/apps/$app.*
  echo "'$app' was removed"
}


declare -A config_template

config_template["ga"]='# In analytics you can view graphs at:
export GOOGLE_ANALYTICS_TOKEN="X-XXXXXXX-1"
'

config_template["webhook"]='# put urls below on each line which can handle POST requests (with json)
'

config_template["cmdhook"]='# put cmds (with fullpath like "/usr/bin/foo bar") below on each line which can handle POST requests (with json)
'

config:edit(){
  local config_type="${1}"
  local appname="${2}"
  if [[ ! $config_type == "pmserver" ]]; then
    apps:exit_if_nonexists $appname
    which curl &>/dev/null || { echo "curl doesn't seem to be installed (which is required for this feature)"; exit 1; }
    if [[ ! -n $EDITOR ]]; then
      echo "no default editor set. Please specify using 'export EDITOR=vim' e.g."
      exit 1
    fi
    configfile=$(process:gettmpfile $appname).$config_type
    if [[ ! -f $configfile ]]; then
      echo "${config_template["$config_type"]}" > $configfile
    fi
    $EDITOR $configfile
  else
    echo "$selfpath/pm server start $2" > $app_config_dir/apps/pmserver.def
    echo "$2" > $app_config_dir/apps/pmserver.port
  fi
}

server:listen(){
  local port="${1}"
  which gawk &>/dev/null || { echo "'gawk' is not installed..which is needed for pm.sh"; }
  while :; do
    gawk 'BEGIN{
      SOCK="/inet/tcp/'$port'/0/0";
      body_size=0;
      #request head
      while( (SOCK |& getline REQ) > 0){
        print REQ;
        if( REQ~/^Content-Length/ ){
          split(REQ,cl,":");
          body_size=cl[2];
        }
        if( REQ~/\r/ ){ break; }
      }
      #request body
      recive_size=0;
      if(body_size > 0){
        while( (SOCK |& getline REQ) > 0){
          print REQ;
          recive_size=recive_size + length(REQ) + 1;
          if(recive_size >= body_size){ break; }
        }
      }
      #response
      RS = ORS = "\r\n"
      Response = "{\"status\":\"received\"}"
      Len = length(Response) + length(ORS)
      print "HTTP/1.0 200"             |& SOCK;
      print "Content-Length: " Len ORS |& SOCK;
      print Response                   |& SOCK;
      system("")
      close(SOCK);
    }'
  done
}

server:parse_appname(){
  local postrequest="${1}"
  local type="${2}"
  appname="${postrequest/POST \/}"
  echo "${appname/\/$type*/}"
}

server:onrequest(){
  local request="${1}"
  local appname
  echo "req=$request"
  if [[ $request =~ (POST \/start\/) ]]; then
    appname=$(server:parse_appname "$request" start)
    $selfpath/pm start $appname
  fi
  if [[ $request =~ (POST \/stop\/) ]]; then
    appname=$(server:parse_appname "$request" stop)
    $selfpath/pm stop $appname
  fi
  if [[ $request =~ (POST \/restart\/) ]]; then
    appname=$(server:parse_appname "$request" restart)
    $selfpath/pm restart $appname
  fi
  if [[ $request =~ (POST \/pull\/) ]]; then
    appname=$(server:parse_appname "$request" pull)
    deffile=$(process:gettmpfile $appname).def
    if [[ -f $deffile ]]; then
      server:gitpull $appname
    else
      echo -e "received webhook: pull $appname (error: no such app)"
    fi
  fi
}

server:start(){
  local port="${1}"
  # check if we have a commandline invocation
  if [[ $port == "start" ]]; then
    port=$2
  fi
  echo "listening on port $port"
  server:listen $port | mappipe server:onrequest
}

server:gitpull(){
  local appname="${1}"
  deffile=$(process:gettmpfile $appname).def
  workdir=$(apps:getworkdir $deffile)
  if [[ -d $workdir/.git ]]; then
    cd $workdir
    echo -e "received webhook: pull $appname, performing git pull"
    set +e
    $selfpath/pm stop $appname
    git pull origin master 2>&1 | awk '{ print "git: "$0 }'
    $selfpath/pm start $appname
    set -e
  else
    echo -e "received webhook: pull $appname (error: $workdir is not a git repo)"
  fi
}

server:kill(){
  killall gawk &>/dev/null # gawk is a strange beast when it comes to child processes
}


config_dir=~/.pm.sh


pid=$$


app:init(){
  for dep in "${dependencies[@]}"; do
    which $dep &>/dev/null || { echo "'$dep' is not installed (pm needs: $dependencies)" && exit 1; }
  done
}

app:help(){
  echo 'Usage:                                                                                                          '
  echo '                                                                                                                '
  echo '  pm init                                      create ~/.pm.conf.sh configfile                                  '
  echo '  pm list                                      list appnames                                                    '
  echo '  pm add <appdir> [appname] [cmd]              add application(dir which contains app definition file) [or cmd] '
  echo '  pm remove <appdir>                           remove application                                               '
  echo '  pm status                                    show app(names) and their status                                 '
  echo '  pm start <appname> [--log]                   start app (and tail logs)                                        '
  echo '  pm stop <appname>                            stop  app                                                        '
  echo '  pm startall                                  start all applications                                           '
  echo '  pm stopall                                   stop all applications                                            '
  echo '  pm tail <appname>                            monitor logs                                                     '
  echo '  pm inspect <appname>                         show all related files, startcmds, env-vars                      '
  echo '  pm debug <appname>                           start application in foreground (for testing purposes)           '
  echo '                                                                                                                '
  if [[ ! -n $ALL ]]; then
    echo '  type 'pm -h' to see all options: receiving github/bitbucket webhooks, pushing to google analytics etc       '
  else
    echo '  pm config ga <appname>                       configure google analytics (opens default editor)              '
    echo '  pm config webhook <appname>                  [todo] add POST webhooks (opens default editor)                '
    echo '  pm config cmdhook <appname>                  [todo] add unix commands (opens default editor)                '
    echo '                                                                                                              '
    echo '  pm config pmserver <port>                    set port of server to receive github/bitbucket webhooks        '
    echo '  pm <start|stop> pmserver [--log]             start/stop server (background) [and watch logs]                '
    echo '                                                                                                              '
    echo '  environment variables:                                                                                      '
    echo '     PM_CONFIG=/my/dir                         configuration path (default: ~/.pm.sh)                         '
    echo '                                                                                                              '
  fi
  echo '                                               ┌─────────────────────────────────────────────────┐              '
  echo '                                               │ docs: https://github.com/coderofsalvation/pm.sh │              '
  echo '                                                                                                                '
}

opts:scancmd "$@"
opts:scanopts "$@"
if [[ -n $1 ]]; then
  shift
fi
app:init && $scope:$cmd "$@"

# wait for all async child processes (because "await ... then" is used in powscript)
[[ $ASYNC == 1 ]] && wait


# cleanup tmp files
if ls /tmp/$(basename $0).tmp.sqz* &>/dev/null; then
  for f in /tmp/$(basename $0).tmp.sqz*; do rm $f; done
fi

exit 0


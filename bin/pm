#!/bin/bash

# powscript general settings
set -e                         # halt on error
set +m                         #
SHELL="$(echo $0)"             # shellname
SHELLNAME="$(basename $SHELL)" # shellname without path
shopt -s lastpipe              # flexible while loops (maintain scope)
shopt -s extglob               # regular expressions
path="$(pwd)"
selfpath="$( dirname "$(readlink -f "$0")" )"
tmpfile="/tmp/$(basename $0).tmp.$(whoami)"
#
# generated by powscript (https://github.com/coderofsalvation/powscript)
#

on () 
{ 
    func="$1";
    shift;
    for sig in "$@";
    do
        trap "$func $sig" "$sig";
    done
}


scope=app
cmd=help

for arg in $@; do
  case $arg in
    exec)
      scope=process
      cmd=$arg
      shift
      ;;
    start)
      scope=process
      cmd=$arg
      shift
      ;;
    stop)
      scope=process
      cmd=$arg
      shift
      ;;
    restart)
      scope=process
      cmd=$arg
      shift
      ;;
    status)
      scope=process
      cmd=$arg
      shift
      ;;
    --force)
      runtime=sh
      shift
      ;;
  esac
done

process:log(){
  date +"%Y-%m-%d %H:%M:%S $*"
  { which logger &>/dev/null && date +"%Y-%m-%d %H:%M:%S $*" | logger -i --tag pm; } &>/dev/null
}

process:gettmpfile(){
  local pname="${1}"
  echo /tmp/.pm.$(basename $pname)
}

process:getpidfile(){
  local pname="${1}"
  echo $(process:gettmpfile $pname).pid
}

process:getpid(){
  local pname="${1}"
  local pidfile=$(process:getpidfile $pname)
  if [[ -f $pidfile ]]; then
    cat $pidfile
  else 
    echo -1
  fi
}

process:getlockfile(){
  local pname="${1}"
  local tmpfile=$(process:gettmpfile $pname)
  echo $tmpfile.lock
}

process:getlogfile(){
  local pname="${1}"
  local tmpfile=$(process:gettmpfile $pname)
  echo $tmpfile.log
}

process:exec(){
  local pname="${1}"
  shift # remove first arg from argument array
  cnt=1
  lockfile=$(process:getlockfile $pname)
  trap "process:log \"#$cnt: $pname killed \$?\"; pkill -P $$" EXIT SIGHUP SIGINT SIGTERM
  while :; do
    process:log "#$cnt $pname started [pid $$]"
    flock -w 0 $lockfile $pname "$@" || exit 1
    code="$?"                                 # check exit status code
    exit="EXIT"
    if [[ $code == 129 ]]; then
      exit=SIGHUP
    fi
    if [[ $code == 130 ]]; then
      exit=SIGINT
    fi
    if [[ $code == 143 ]]; then
      exit=SIGTERM
    fi
    process:log "#$cnt $pname $exit [$code]"
    sleep 5s                                  # wait for seconds until next boot
    cnt=$(($cnt+1))                           # increment counter
  done
}

process:start(){
  local pname="${1}"
  shift # remove first arg from argument array
  pidfile=$(process:gettmpfile $pname).pid
  logfile=$(process:getlogfile $pname)
  lockfile=$(process:getlockfile $pname)
  flock -w 0 $lockfile sleep 0.1s || { echo "already started"; exit 1; }
  nohup $selfpath/pm exec $pname "$@" 1>$logfile.stdout 2>$logfile.stderr &
  echo $! > $pidfile 
  echo -e "press CTRL-C to stop logmonitor:\n"
  set -x
  tailf $logfile.stdout $logfile.stderr
}

process:stop(){
  local pname="${1}"
  shift # remove first arg
  pid=$(process:getpid $pname)
  if [[ ! $pid == "-1" ]]; then
    echo killing pid $pid 
    rm $(process:getpidfile $pname)
    pkill -P $pid
  else
    echo "$pname is not running"
  fi
}

process:restart(){
  local pname="${1}"
  process:stop $pname &
  wait 
  process:start $pname
}

process:status(){
  local pname="${1}"
  ps=$(ps au)
  seen=()
  cols="$(echo "$ps" | head -n1)"                        # print cols header
  printf "%-10s %-10s %s\n" "APP" "STATUS" "$cols"
  echo "$ps" | grep "flock.*pm\..*\.lock" >> $tmpfile.ps # print psdata
  for lockfile in $(ls /tmp/.pm.*.lock); do
    appname=${lockfile/*pm\./}
    appname=${appname/\.lock/}
    echo $appname
    flock -w 0 $lockfile sleep 0.1s && status=running || status=stopped
    if [[ $status == "running" ]]; then
      printf "%-10s %-10s" "$appname" "$status"
    else
      line="$(fgrep "$lockfile" $tmpfile.ps)"
      printf "%-10s %-10s %s\n" "$appname" "$status" "$line"
    fi
  done
}
     


pid=$$
dependencies="flock awk date sleep ps head"


app:init(){
  for dep in "${dependencies[@]}"; do
    which $dep &>/dev/null || { echo "'$dep' is not installed (pm needs: $dependencies)" && exit 1; }
  done
}

app:help(){
  echo 'Usage:
  pm start <cmd> [args] [..]
  '
}

app:init && $scope:$cmd "$@"

# wait for all async child processes (because "await ... then" is used in powscript)
[[ $ASYNC == 1 ]] && wait


# cleanup tmp files
if ls /tmp/$(basename $0).tmp.sqz* &>/dev/null; then
  for f in /tmp/$(basename $0).tmp.sqz*; do rm $f; done
fi

exit 0

